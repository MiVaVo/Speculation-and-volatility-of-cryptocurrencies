# x <- ts(rnorm(120,0,3) + 1:120 + 20*sin(2*pi*(1:120)/12), frequency=12)
# temp = rnorm(length(x), 20, 30)
length(R)
length(V)
V
length(V)
model = auto.arima(R, xreg = data.frame(temp = temp))
# x <- ts(rnorm(120,0,3) + 1:120 + 20*sin(2*pi*(1:120)/12), frequency=12)
# temp = rnorm(length(x), 20, 30)
length(R)
length(V)
V
V[:-1]
V[-1]
len(V[-1])
length(V[-1])
V[-1][1]
V[-1][10]
V[-1][100]
V[-1]
V[-1][239]
V[-1][249]
V[249]
V
V
V
seq(counts-trend_lasts,counts-1,1)
counts
counts=trend_lasts
seq(counts-trend_lasts,counts-1,1)
logturnover[seq(counts-trend_lasts,counts-1,1)]
logturnover[seq(counts-trend_lasts,counts-1,1),'volume']
seq(counts-trend_lasts,counts-1,1)
logturnover[seq(counts-trend_lasts,counts,1),'volume']
counts
counts-trend_lasts
logturnover[seq(counts-trend_lasts,counts-1,1),'volume']
# x <- ts(rnorm(120,0,3) + 1:120 + 20*sin(2*pi*(1:120)/12), frequency=12)
# temp = rnorm(length(x), 20, 30)
length(R)
length(V)
length(R)
length(V)
library(forecast)
library(quantmod)
# install.packages('forecast')
df=read.csv('all-crypto-currencies/crypto-markets.csv')
# unique(df[,'name'])
df_new=df[c('name','date','open','high','low','close','volume','market')]
df_new=df_new[df_new[,'name']=='Bitcoin',]
logturnover=log(df_new['volume']+0.00000255)
counts=0
trend_lasts=2
V=c()
for (i in seq(1,dim(logturnover)[1],1)){
if (counts<trend_lasts){
counts=counts+1
V<-c(V,0)
next
}
V<-c(V,logturnover[counts,'volume']-mean(logturnover[seq(counts-trend_lasts,counts-1,1),'volume']))
counts=counts+1
}
counts=trend_lasts
logturnover[seq(counts-trend_lasts,counts-1,1),'volume']
series_to_analyze[-length(series_to_analyze)]
# periodReturn()
diff(series_to_analyze)[0]
# periodReturn()
diff(series_to_analyze)
series_to_analyze
seq(1,dim(logturnover)[1],1)
library(forecast)
library(quantmod)
# install.packages('forecast')
df=read.csv('all-crypto-currencies/crypto-markets.csv')
# unique(df[,'name'])
df_new=df[c('name','date','open','high','low','close','volume','market')]
df_new=df_new[df_new[,'name']=='Bitcoin',]
logturnover=log(df_new['volume']+0.00000255)
counts=0
trend_lasts=2
V=c()
for (i in seq(1,dim(logturnover)[1],1)){
if (i<trend_lasts){
V<-c(V,0)
next
}
V<-c(V,logturnover[i,'volume']-mean(logturnover[seq(i-trend_lasts,i-1,1),'volume']))
}
# x <- ts(rnorm(120,0,3) + 1:120 + 20*sin(2*pi*(1:120)/12), frequency=12)
# temp = rnorm(length(x), 20, 30)
length(R)
length(V)
length(V[-1])
V=V[-1]
length(V[-1])
length(R)
length(V)
R
V
length(R)
seq(246,length(R),1)
length(V[seq(246,length(V),1)])
length(R[seq(246,length(R),1)])
length(V[seq(246,length(V),1)])
R=R[seq(246,length(R),1)]
V=V[seq(246,length(V),1)]
R*V
mixed_variable=R*V
length(mixed_variable)
length(V)
data.frame(mixed_variable)
model = auto.arima(R, xreg = data.frame(mixed_variable))
model
model = auto.arima(R[seq(,length(R),1)], xreg = data.frame(mixed_variable[seq(,length(mixed_variable),1)]))
model = auto.arima(R[seq(200,length(R),1)],
xreg = data.frame(mixed_variable[seq(200,length(mixed_variable),1)]))
model
length(R)
model = auto.arima(R[seq(0,length(R)-1000,1)],
xreg = data.frame(mixed_variable[seq(0,length(mixed_variable)-1000,1)]))
model
library(forecast)
library(quantmod)
# install.packages('forecast')
df=read.csv('all-crypto-currencies/crypto-markets.csv')
# unique(df[,'name'])
df_new=df[c('name','date','open','high','low','close','volume','market')]
df_new=df_new[df_new[,'name']=='Bitcoin',]
logturnover=log(df_new['volume']+0.00000255)
counts=0
trend_lasts=50
V=c()
for (i in seq(1,dim(logturnover)[1],1)){
if (i<trend_lasts){
V<-c(V,0)
next
}
V<-c(V,logturnover[i,'volume']-mean(logturnover[seq(i-trend_lasts,i-1,1),'volume']))
}
counts=trend_lasts
logturnover[seq(counts-trend_lasts,counts-1,1),'volume']
# par(mar=c(1,1,1,1))
# tsdisplay(V[seq(0,length(V),1)])
###################### CREATE RETURN SERIES ############
series_to_analyze=unlist(df_new['close'])
# periodReturn()
diff(series_to_analyze)
R=diff(series_to_analyze)/series_to_analyze[-length(series_to_analyze)]
# x <- ts(rnorm(120,0,3) + 1:120 + 20*sin(2*pi*(1:120)/12), frequency=12)
# temp = rnorm(length(x), 20, 30)
V=V[-1]
R=R[seq(246,length(R),1)]
V=V[seq(246,length(V),1)]
mixed_variable=R*V
length(mixed_variable)
model = auto.arima(R[seq(0,length(R)-1000,1)],
xreg = data.frame(mixed_variable[seq(0,length(mixed_variable)-1000,1)]))
model
tsdisplay(V)
library(forecast)
library(quantmod)
# install.packages('forecast')
df=read.csv('all-crypto-currencies/crypto-markets.csv')
# unique(df[,'name'])
df_new=df[c('name','date','open','high','low','close','volume','market')]
df_new=df_new[df_new[,'name']=='Bitcoin',]
logturnover=log(df_new['volume']+0.00000255)
counts=0
trend_lasts=50
V=c()
for (i in seq(1,dim(logturnover)[1],1)){
if (i<trend_lasts){
V<-c(V,0)
next
}
V<-c(V,logturnover[i,'volume']-mean(logturnover[seq(i-trend_lasts,i-1,1),'volume']))
}
counts=trend_lasts
logturnover[seq(counts-trend_lasts,counts-1,1),'volume']
# par(mar=c(1,1,1,1))
# tsdisplay(V[seq(0,length(V),1)])
###################### CREATE RETURN SERIES ############
series_to_analyze=unlist(df_new['close'])
# periodReturn()
diff(series_to_analyze)
R=diff(series_to_analyze)/series_to_analyze[-length(series_to_analyze)]
# x <- ts(rnorm(120,0,3) + 1:120 + 20*sin(2*pi*(1:120)/12), frequency=12)
# temp = rnorm(length(x), 20, 30)
V=V[-1]
R=R[seq(260,length(R),1)]
V=V[seq(260,length(V),1)]
tsdisplay(V)
mixed_variable=R*V
length(mixed_variable)
tsdisplay(V)
library(forecast)
library(quantmod)
# install.packages('forecast')
df=read.csv('all-crypto-currencies/crypto-markets.csv')
# unique(df[,'name'])
df_new=df[c('name','date','open','high','low','close','volume','market')]
df_new=df_new[df_new[,'name']=='Bitcoin',]
logturnover=log(df_new['volume']+0.00000255)
counts=0
trend_lasts=50
V=c()
for (i in seq(1,dim(logturnover)[1],1)){
if (i<trend_lasts){
V<-c(V,0)
next
}
V<-c(V,logturnover[i,'volume']-mean(logturnover[seq(i-trend_lasts,i-1,1),'volume']))
}
counts=trend_lasts
logturnover[seq(counts-trend_lasts,counts-1,1),'volume']
# par(mar=c(1,1,1,1))
# tsdisplay(V[seq(0,length(V),1)])
###################### CREATE RETURN SERIES ############
series_to_analyze=unlist(df_new['close'])
# periodReturn()
diff(series_to_analyze)
R=diff(series_to_analyze)/series_to_analyze[-length(series_to_analyze)]
# x <- ts(rnorm(120,0,3) + 1:120 + 20*sin(2*pi*(1:120)/12), frequency=12)
# temp = rnorm(length(x), 20, 30)
V=V[-1]
R=R[seq(300,length(R),1)]
V=V[seq(300,length(V),1)]
tsdisplay(V)
mixed_variable=R*V
length(mixed_variable)
model = auto.arima(R[seq(0,length(R)-1000,1)],
xreg = data.frame(mixed_variable[seq(0,length(mixed_variable)-1000,1)]))
model
summary(model)
model = auto.arima(R[seq(0,length(R),1)],
xreg = data.frame(mixed_variable[seq(0,length(mixed_variable),1)]))
summary(model)
tsdisplay(R[seq(0,length(R),1)])
model.residuals
model['residuals']
tsdispmodel['residuals']
tsdisplay(model['residuals'])
tsdisplay(unlist(model['residuals']))
unlist(model['residuals'])
unlist(model['residuals'])
tsdisplay(unlist(model['residuals']))
length(unlist(model['residuals']))
par(mar=c(1,1,1,1))
tsdisplay(unlist(model['residuals']))
par(mar=c(1,0.1,1,1))
tsdisplay(unlist(model['residuals']))
min(model['residuals'])
resids=unlist(model['residuals'])
tsdisplay(resids)
tsdisplay(resids*10)
tsdisplay(resids*100)
tsdisplay(resids)
tsdisplay(R[seq(0,length(R),1)])
library(forecast)
library(quantmod)
# install.packages('forecast')
df=read.csv('all-crypto-currencies/crypto-markets.csv')
# unique(df[,'name'])
df_new=df[c('name','date','open','high','low','close','volume','market')]
df_new=df_new[df_new[,'name']=='Bitcoin',]
logturnover=log(df_new['volume']+0.00000255)
counts=0
trend_lasts=50
V=c()
for (i in seq(1,dim(logturnover)[1],1)){
if (i<trend_lasts){
V<-c(V,0)
next
}
V<-c(V,logturnover[i,'volume']-mean(logturnover[seq(i-trend_lasts,i-1,1),'volume']))
}
counts=trend_lasts
logturnover[seq(counts-trend_lasts,counts-1,1),'volume']
# par(mar=c(1,1,1,1))
# tsdisplay(V[seq(0,length(V),1)])
###################### CREATE RETURN SERIES ############
series_to_analyze=unlist(df_new['close'])
# periodReturn()
diff(series_to_analyze)
R=diff(series_to_analyze)/series_to_analyze[-length(series_to_analyze)]
# x <- ts(rnorm(120,0,3) + 1:120 + 20*sin(2*pi*(1:120)/12), frequency=12)
# temp = rnorm(length(x), 20, 30)
V=V[-1]
R=R[seq(300,length(R),1)]
V=V[seq(300,length(V),1)]
tsdisplay(R[seq(0,length(R),1)])
mixed_variable=R*V
length(mixed_variable)
model = auto.arima(R[seq(0,length(R),1)],
xreg = data.frame(mixed_variable[seq(0,length(mixed_variable),1)]))
summary(model)
# par(mar=c(1,0.1,1,1))
resids=unlist(model['residuals'])
tsdisplay(resids)
min(model['residuals'])
length(unlist(model['residuals']))
tsdisplay(resids)
par(mar=c(1,1,1,1))
tsdisplay(resids)
par(mar=c(5,5,5,5))
resids=unlist(model['residuals'])
tsdisplay(resids)
par(mar=c(0.1,0.1,0.1,0.1))
resids=unlist(model['residuals'])
tsdisplay(resids)
resids
tsdisplay(resids[seq(1,1000,1)])
dev.off()
tsdisplay(resids[seq(1,1000,1)])
dev.off()
par(mar = rep(2, 4))
dev.off()
par(mar = rep(2, 4))
tsdisplay(resids[seq(1,1000,1)])
tsdisplay(resids[seq(1,1000,1)])
tsdisplay(resids[seq(1,100,1)])
par(mar = rep(2, 4))
dev.off()
par(mar = rep(2, 4))
dev.off()
par(mar = rep(2, 4))
tsdisplay(resids[seq(1,100,1)])
dev.off()
par(mar = rep(2, 4))
resids=unlist(model['residuals'])
tsdisplay(resids[seq(1,100,1)])
par(mar = rep(1, 4))
tsdisplay(resids[seq(1,100,1)])
min(model['residuals'])
length(unlist(model['residuals']))
par(mar = rep(2, 4))
dev.off()
par(mar = rep(1, 4))
resids=unlist(model['residuals'])
tsdisplay(resids[seq(1,100,1)])
par(mar = rep(5, 4))
resids=unlist(model['residuals'])
tsdisplay(resids[seq(1,100,1)])
min(model['residuals'])
length(unlist(model['residuals']))
par(mar = rep(2, 4))
dev.off()
par(mar = rep(5, 4))
resids=unlist(model['residuals'])
tsdisplay(resids[seq(1,100,1)])
tsdisplay(resids[seq(1,100,1)])
summary(model)
par(mar=c(0.1,0.1,0.1,0.1))
resids=unlist(model['residuals'])
tsdisplay(resids[seq(1,100,1)])
min(model['residuals'])
length(unlist(model['residuals']))
par(mar = rep(1, 4))
dev.off()
tsdisplay(resids[seq(1,100,1)])
min(model['residuals'])
length(unlist(model['residuals']))
par(mar = rep(1, 4))
dev.off()
par(mar = rep(1, 4))
tsdisplay(resids[seq(1,100,1)])
dev.off()
tsdisplay(resids[seq(1,100,1)])
graphics.off()
tsdisplay(resids[seq(1,100,1)])
par(mar = rep(1, 4))
dev.off()
par(mar = rep(1, 4))
graphics.off()
tsdisplay(resids[seq(1,100,1)])
tsdisplay(resids[seq(1,100,1)])
windows()
tsdisplay(resids[seq(1,100,1)])
dev.off()
windows()
tsdisplay(resids[seq(1,100,1)])
windows()
windows()
tsdisplay(resids)
tsdisplay(resids)
windows()
tsdisplay(resids)
dev.off()
windows()
tsdisplay(resids)
library(forecast)
library(quantmod)
# install.packages('forecast')
df=read.csv('all-crypto-currencies/crypto-markets.csv')
# unique(df[,'name'])
df_new=df[c('name','date','open','high','low','close','volume','market')]
df_new=df_new[df_new[,'name']=='Bitcoin',]
logturnover=log(df_new['volume']+0.00000255)
counts=0
trend_lasts=2
V=c()
for (i in seq(1,dim(logturnover)[1],1)){
if (i<trend_lasts){
V<-c(V,0)
next
}
V<-c(V,logturnover[i,'volume']-mean(logturnover[seq(i-trend_lasts,i-1,1),'volume']))
}
counts=trend_lasts
logturnover[seq(counts-trend_lasts,counts-1,1),'volume']
# par(mar=c(1,1,1,1))
# tsdisplay(V[seq(0,length(V),1)])
###################### CREATE RETURN SERIES ############
series_to_analyze=unlist(df_new['close'])
# periodReturn()
diff(series_to_analyze)
R=diff(series_to_analyze)/series_to_analyze[-length(series_to_analyze)]
V=V[-1]
R=R[seq(300,length(R),1)]
V=V[seq(300,length(V),1)]
tsdisplay(R[seq(0,length(R),1)])
mixed_variable=R*V
length(mixed_variable)
model = auto.arima(R[seq(0,length(R),1)],
xreg = data.frame(mixed_variable[seq(0,length(mixed_variable),1)]))
summary(model)
par(mar=c(0.1,0.1,0.1,0.1))
resids=unlist(model['residuals'])
windows()
tsdisplay(resids)
library(forecast)
library(quantmod)
# install.packages('forecast')
df=read.csv('all-crypto-currencies/crypto-markets.csv')
# unique(df[,'name'])
df_new=df[c('name','date','open','high','low','close','volume','market')]
df_new=df_new[df_new[,'name']=='Bitcoin',]
logturnover=log(df_new['volume']+0.00000255)
counts=0
trend_lasts=2
V=c()
for (i in seq(1,dim(logturnover)[1],1)){
if (i<trend_lasts){
V<-c(V,0)
next
}
V<-c(V,logturnover[i,'volume']-mean(logturnover[seq(i-trend_lasts,i-1,1),'volume']))
}
counts=trend_lasts
logturnover[seq(counts-trend_lasts,counts-1,1),'volume']
# par(mar=c(1,1,1,1))
# tsdisplay(V[seq(0,length(V),1)])
###################### CREATE RETURN SERIES ############
series_to_analyze=unlist(df_new['close'])
# periodReturn()
diff(series_to_analyze)
R=diff(series_to_analyze)/series_to_analyze[-length(series_to_analyze)]
V=V[-1]
R=R[seq(300,length(R),1)]
V=V[seq(300,length(V),1)]
tsdisplay(R[seq(0,length(R),1)])
mixed_variable=R*V
length(mixed_variable)
model = auto.arima(R[seq(0,length(R),1)],
xreg = data.frame(mixed_variable[seq(0,length(mixed_variable),1)]))
summary(model)
par(mar=c(0.1,0.1,0.1,0.1))
resids=unlist(model['residuals'])
windows()
tsdisplay(resids)
library(forecast)
library(quantmod)
# install.packages('forecast')
df=read.csv('all-crypto-currencies/crypto-markets.csv')
# unique(df[,'name'])
df_new=df[c('name','date','open','high','low','close','volume','market')]
df_new=df_new[df_new[,'name']=='Bitcoin',]
logturnover=log(df_new['volume']+0.00000255)
counts=0
trend_lasts=50
V=c()
for (i in seq(1,dim(logturnover)[1],1)){
if (i<trend_lasts){
V<-c(V,0)
next
}
V<-c(V,logturnover[i,'volume']-mean(logturnover[seq(i-trend_lasts,i-1,1),'volume']))
}
counts=trend_lasts
logturnover[seq(counts-trend_lasts,counts-1,1),'volume']
# par(mar=c(1,1,1,1))
# tsdisplay(V[seq(0,length(V),1)])
###################### CREATE RETURN SERIES ############
series_to_analyze=unlist(df_new['close'])
# periodReturn()
diff(series_to_analyze)
R=diff(series_to_analyze)/series_to_analyze[-length(series_to_analyze)]
V=V[-1]
R=R[seq(300,length(R),1)]
V=V[seq(300,length(V),1)]
tsdisplay(R[seq(0,length(R),1)])
mixed_variable=R*V
length(mixed_variable)
model = auto.arima(R[seq(0,length(R),1)],
xreg = data.frame(mixed_variable[seq(0,length(mixed_variable),1)]))
summary(model)
par(mar=c(0.1,0.1,0.1,0.1))
resids=unlist(model['residuals'])
windows()
tsdisplay(resids)
