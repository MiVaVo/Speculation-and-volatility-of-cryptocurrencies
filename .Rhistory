}
}
# 3 . Conduct Granger casuality test to test the H0, which is as follows:
# Volatility, associated  with speculative processes on cryptocurrency X cause ( based on granger test)
# speculative volatility on cryptocurrency Y, where X and Y are currencies from c('BTC','ETH','XRP')
# 3.1. BTC -> ETH
tsdisplay(unlist(fits_of_garch[2]))
grangertest(unlist(fits_of_garch[2]) ~ unlist(fits_of_garch[1]), order = 3) #0.194 H0 rejected
# 3.2. ETH -> BTC
grangertest(unlist(fits_of_garch[1]) ~ unlist(fits_of_garch[2]), order = 3) #0.001692 ** H0 not rejected
# 3.3. BTC -> XRP
grangertest(unlist(fits_of_garch[3]) ~ unlist(fits_of_garch[1]), order = 3) #0.8227 H0 rejected
# 3.4. XRP -> BTC
grangertest(unlist(fits_of_garch[1]) ~ unlist(fits_of_garch[3]), order = 3) #0.8551 H0 rejected
# 3.3. ETH -> XRP
grangertest(unlist(fits_of_garch[3]) ~ unlist(fits_of_garch[2]), order = 3) #0.03617 * H0 not rejected
# 3.4. XRP -> ETH
grangertest(unlist(fits_of_garch[2]) ~ unlist(fits_of_garch[3]), order = 3) # 0.6793 H0 rejected
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(lmtest)
library(rugarch)
source('funcs.R')
# 1. Prepare overall data
df=read.csv('merged_all.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
crypto_abr=c('BTC','ETH','XRP')
fits_of_garch=list()
cor(df[,-1])
cryptomodel=list()
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(lmtest)
library(rugarch)
source('funcs.R')
# 1. Prepare overall data
df=read.csv('datasets_created_python/merged_all.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
crypto_abr=c('BTC','ETH','XRP')
fits_of_garch=list()
cor(df[,-1])
models_all=list()
# 2. Loop over all currencies and calculate volatility, that was associated with speculative processes
tsdisplay(y_here)
for (cryptos in crypto_abr){
print(cryptos)
steping=dim(df)[1]-1
for (i in seq(1,dim(df)[1]-steping,steping)){
dates=df_new[,grepl('date', colnames(df_new))]
df_new=df[seq(i,i+steping,1),]
# 2.1 Prepare dep.variable y, that will be used in ARMAX-GARCH model
y_here=df_new[,grepl(paste('R_',cryptos,sep=''), colnames(df_new)) | grepl('date', colnames(df_new)) ]
y_here <- xts(y_here[,-1], order.by=as.POSIXct(y_here$date))
# 2.2 Prepare exogenious variable, that will be used in ARMAX part of ARMAX-GARCH model
ext_regressor_here=df_new[,grepl(paste('RV_',cryptos,sep=''), colnames(df_new))]
# 2.3 Describe ARMAX(1,1)-GARCH(1,1) model
g1=ugarchspec(variance.model = list(model = "apARCH", external.regressors = as.matrix(ext_regressor_here),
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1), external.regressors = as.matrix(ext_regressor_here),
include.mean = TRUE),
# mean.model  = list(external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "std")
# 2.4 Fit model with appropriate solvers
g1fit=ugarchfit(g1,data=y_here,solver='hybrid')
models_all<-list(models_all,list(g1fit))
# 2.5 Prepare dataset for GARCH regression
df_to_reg=cbind(g1fit@fit$sigma,ext_regressor_here)
colnames(df_to_reg)=c(paste('sigma_',cryptos,sep=''),paste('RV_',cryptos,sep=''))
df_to_reg=as.data.frame(df_to_reg)
# 2.6 Fit regression model GARCH(1,1)~b0+b1*Speculation , where Speculation is the measure of speculation
# as described in 'Blau M. Price dynamics and speculative trading in bitcoinBenjamin,2017'
# and is based on 'Guillermo L. Dynamic Volume-Return Relation of Individual Stocks,2000'
m1<-lm(df_to_reg[,1]~df_to_reg[,2],data = df_to_reg)
print(summary(m1))
# 2.7 Save volatility of a given cryptocyrrency, that is associated (caused by) with speculation
fits_of_garch=append(fits_of_garch,list(m1$fitted.values))
}
}
# 3 . Conduct Granger casuality test to test the H0, which is as follows:
# Volatility, associated  with speculative processes on cryptocurrency X cause ( based on granger test)
# speculative volatility on cryptocurrency Y, where X and Y are currencies from c('BTC','ETH','XRP')
# 3.1. BTC -> ETH
grangertest(log(unlist(fits_of_garch[2])) ~ log(unlist(fits_of_garch[1])), order = 3) #0.194 H0 rejected #0.16
# 3.2. ETH -> BTC
grangertest(log(unlist(fits_of_garch[1])) ~ log(unlist(fits_of_garch[2])), order = 3) #0.001692 ** H0 not rejected  0.001936 **
# 3.3. BTC -> XRP
grangertest(log(unlist(fits_of_garch[3])) ~ log(unlist(fits_of_garch[1])), order = 3) #0.8227 H0 rejected
# 3.4. XRP -> BTC
grangertest(log(unlist(fits_of_garch[1])) ~ log(unlist(fits_of_garch[3])), order = 3) #0.8551 H0 rejected
# 3.3. ETH -> XRP
grangertest(log(unlist(fits_of_garch[3])) ~ log(unlist(fits_of_garch[2])), order = 3) #0.03617 * H0 not rejected
# 3.4. XRP -> ETH
grangertest(log(unlist(fits_of_garch[2])) ~ log(unlist(fits_of_garch[3])), order = 3) # 0.6793 H0 rejected
models_all<-append(models_all,list(g1fit))
models_all<-append(models_all,list(g1fit))
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(lmtest)
library(rugarch)
source('funcs.R')
# 1. Prepare overall data
df=read.csv('datasets_created_python/merged_all.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
crypto_abr=c('BTC','ETH','XRP')
fits_of_garch=list()
cor(df[,-1])
models_all=list()
# 2. Loop over all currencies and calculate volatility, that was associated with speculative processes
tsdisplay(y_here)
for (cryptos in crypto_abr){
print(cryptos)
steping=dim(df)[1]-1
for (i in seq(1,dim(df)[1]-steping,steping)){
dates=df_new[,grepl('date', colnames(df_new))]
df_new=df[seq(i,i+steping,1),]
# 2.1 Prepare dep.variable y, that will be used in ARMAX-GARCH model
y_here=df_new[,grepl(paste('R_',cryptos,sep=''), colnames(df_new)) | grepl('date', colnames(df_new)) ]
y_here <- xts(y_here[,-1], order.by=as.POSIXct(y_here$date))
# 2.2 Prepare exogenious variable, that will be used in ARMAX part of ARMAX-GARCH model
ext_regressor_here=df_new[,grepl(paste('RV_',cryptos,sep=''), colnames(df_new))]
# 2.3 Describe ARMAX(1,1)-GARCH(1,1) model
g1=ugarchspec(variance.model = list(model = "sGARCH", external.regressors = as.matrix(ext_regressor_here),
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1), external.regressors = as.matrix(ext_regressor_here),
include.mean = TRUE),
# mean.model  = list(external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "std")
# 2.4 Fit model with appropriate solvers
g1fit=ugarchfit(g1,data=y_here,solver='hybrid')
models_all<-append(models_all,list(g1fit))
# 2.5 Prepare dataset for GARCH regression
df_to_reg=cbind(g1fit@fit$sigma,ext_regressor_here)
colnames(df_to_reg)=c(paste('sigma_',cryptos,sep=''),paste('RV_',cryptos,sep=''))
df_to_reg=as.data.frame(df_to_reg)
# 2.6 Fit regression model GARCH(1,1)~b0+b1*Speculation , where Speculation is the measure of speculation
# as described in 'Blau M. Price dynamics and speculative trading in bitcoinBenjamin,2017'
# and is based on 'Guillermo L. Dynamic Volume-Return Relation of Individual Stocks,2000'
m1<-lm(df_to_reg[,1]~df_to_reg[,2],data = df_to_reg)
print(summary(m1))
# 2.7 Save volatility of a given cryptocyrrency, that is associated (caused by) with speculation
fits_of_garch=append(fits_of_garch,list(m1$fitted.values))
}
}
# 3 . Conduct Granger casuality test to test the H0, which is as follows:
# Volatility, associated  with speculative processes on cryptocurrency X cause ( based on granger test)
# speculative volatility on cryptocurrency Y, where X and Y are currencies from c('BTC','ETH','XRP')
# 3.1. BTC -> ETH
grangertest(log(unlist(fits_of_garch[2])) ~ log(unlist(fits_of_garch[1])), order = 3) #0.194 H0 rejected #0.16
# 3.2. ETH -> BTC
grangertest(log(unlist(fits_of_garch[1])) ~ log(unlist(fits_of_garch[2])), order = 3) #0.001692 ** H0 not rejected  0.001936 **
# 3.3. BTC -> XRP
grangertest(log(unlist(fits_of_garch[3])) ~ log(unlist(fits_of_garch[1])), order = 3) #0.8227 H0 rejected
# 3.4. XRP -> BTC
grangertest(log(unlist(fits_of_garch[1])) ~ log(unlist(fits_of_garch[3])), order = 3) #0.8551 H0 rejected
# 3.3. ETH -> XRP
grangertest(log(unlist(fits_of_garch[3])) ~ log(unlist(fits_of_garch[2])), order = 3) #0.03617 * H0 not rejected
# 3.4. XRP -> ETH
grangertest(log(unlist(fits_of_garch[2])) ~ log(unlist(fits_of_garch[3])), order = 3) # 0.6793 H0 rejected
############################# 2.Visualize models
models_all[1]
############################# 2.Visualize models
plot(models_all[1],which='all')
models_all[1]
models_all[1][1]
unlist(models_all[1])
unlist(models_all[1])
models_all
models_all
unlist(models_all)
unlist(models_all[[1]])
models_all[[1]]
############################# 2.Visualize models
plot(models_all[[1]],which='all')
plot(models_all[[1]],which=1)
plot(models_all[[2]],which=1)
plot(models_all[[3]],which=1)
plot(models_all[[3]],which=1,add=TRUE)
plot(models_all[[1]],which=1,add=TRUE)
############################# 2.Visualize models
par(new=TRUE)
plot(models_all[[1]],which=1,add=TRUE)
plot(models_all[[1]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
############################# 2.Visualize models
par(new=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE, ylim = c(0,1.5))
plot(models_all[[2]],which=1,add=TRUE, ylim = c(-1,1.5))
plot(models_all[[2]],which=1,add=TRUE, ylim = c(-1,1.5))
plot(models_all[[2]],which=1,add=TRUE)
par(mfrow=c(3,1))
plot(models_all[[2]],which=1,add=TRUE)
par(mfrow=c(1,3))
plot(models_all[[2]],which=1,add=TRUE)
par(mfrow=c(3,3))
plot(models_all[[2]],which=1,add=TRUE)
par(mfrow=c(3,1))
plot(models_all[[2]],which=1,add=TRUE)
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(lmtest)
library(rugarch)
source('funcs.R')
# 1. Prepare overall data
df=read.csv('datasets_created_python/merged_all.csv')
df$date=as.POSIXct(as.Date(df$date))
######################### 1. Visualize returns
redtrans = rgb(255, 0, 0, 225, maxColorValue=255)
greentrans=rgb(0, 255, 0, 225, maxColorValue=255)
bluetrans=rgb(0, 0, 255, 225, maxColorValue=255)
par(mar = rep(2, 4))
par(mfrow=c(3,1))
plot(models_all[[2]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
############################# 2.Visualize models
par(new=TRUE)
par(mfrow=c(3,1))
plot(models_all[[2]],which=1,add=TRUE)
############################# 2.Visualize models
par(new=TRUE)
par(mfrow=c(3,1))
plot(models_all[[2]],which=1,add=TRUE)
par(mfrow=c(3,1))
par(new=TRUE)
par(mfrow=c(3,1))
par(mar = rep(2, 4))
############################# 2.Visualize models
par(new=TRUE)
par(mar = rep(2, 4))
par(mfrow=c(3,1))
plot(models_all[[2]],which=1,add=TRUE)
par(new=TRUE)
par(mar = rep(2, 4))
par(mfrow=c(3,1))
plot(models_all[[1]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
plot(models_all[[3]],which=1,add=TRUE)
plot(models_all[[1]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
plot(models_all[[3]],which=1,add=TRUE)
plot(models_all[[3]],which=1,add=TRUE)
plot(models_all[[3]],which=1,add=TRUE)
plot(models_all[[1]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
plot(models_all[[1]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
plot(models_all[[3]],which=1,add=TRUE)
legend("topleft", cex=0.8,text.font=0.9, legend =c("Доходность USD/BTC", "Доходность USD/ETH", "Доходность USD/XRP"),
col = c( "red", "blue", "green"),lty = 1:3,lwd = 2, bty = "n")
par(new=TRUE)
par(mar = rep(2, 4))
par(mfrow=c(3,1))
plot(models_all[[1]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
plot(models_all[[3]],which=1,add=TRUE)
############################# 2.Visualize models
par(new=TRUE)
par(mar = rep(2, 4))
par(mfrow=c(3,1))
plot(models_all[[1]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
plot(models_all[[1]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
plot(models_all[[3]],which=1,add=TRUE)
plot(models_all[[1]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
plot(models_all[[3]],which=1,add=TRUE)
plot(models_all[[1]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
plot(models_all[[1]],which=1,add=TRUE)
plot(models_all[[2]],which=1,add=TRUE)
plot(models_all[[3]],which=1,add=TRUE)
############################# 2.Visualize models
x=models_all[[1]]
vmodel  = x@model$modeldesc$vmodel
vmodel
T = x@model$modeldata$T
T
insample = 1:T
xdates  = x@model$modeldata$index[insample]
xseries = x@model$modeldata$data[insample]
xsigma  = x@fit$sigma
ci = 2
plot(xdates, xseries, type = "l",  col = "steelblue", ylab = "Returns", xlab="Time",
main = "Series with 2 Conditional SD Superimposed", cex.main = 0.8)
lines(xdates, +ci* xsigma , col = "tomato1")
lines(xdates, -ci* xsigma, col = "tomato1")
mtext(paste("GARCH model : ", vmodel), side = 4, adj = 0, padj=0, col = "gray", cex = 0.5)
if(vmodel == "fGARCH"){
mtext(paste("fGARCH submodel: ", x@model$modeldesc$vsubmodel, sep = ""), side = 4, adj = 0, padj=1.5, col = "gray", cex = 0.5)
}
abline(h = 0, col = "grey", lty = 3)
grid()
plot(x)
plot(x,whic='all')
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(lmtest)
library(rugarch)
source('funcs.R')
# 1. Prepare overall data
df=read.csv('datasets_created_python/merged_all.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
crypto_abr=c('BTC','ETH','XRP')
fits_of_garch=list()
cor(df[,-1])
models_all=list()
# 2. Loop over all currencies and calculate volatility, that was associated with speculative processes
tsdisplay(y_here)
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(lmtest)
library(rugarch)
source('funcs.R')
# 1. Prepare overall data
df=read.csv('datasets_created_python/merged_all.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
crypto_abr=c('BTC','ETH','XRP')
fits_of_garch=list()
cor(df[,-1])
models_all=list()
# 2. Loop over all currencies and calculate volatility, that was associated with speculative processes
tsdisplay(y_here)
cryptos
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(lmtest)
library(rugarch)
source('funcs.R')
# 1. Prepare overall data
df=read.csv('datasets_created_python/merged_all.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
crypto_abr=c('BTC','ETH','XRP')
fits_of_garch=list()
cor(df[,-1])
models_all=list()
# 2. Loop over all currencies and calculate volatility, that was associated with speculative processes
tsdisplay(y_here)
for (cryptos in crypto_abr){
print(cryptos)
steping=dim(df)[1]-1
for (i in seq(1,dim(df)[1]-steping,steping)){
dates=df_new[,grepl('date', colnames(df_new))]
df_new=df[seq(i,i+steping,1),]
# 2.1 Prepare dep.variable y, that will be used in ARMAX-GARCH model
y_here=df_new[,grepl(paste('R_',cryptos,sep=''), colnames(df_new)) | grepl('date', colnames(df_new)) ]
y_here <- xts(y_here[,-1], order.by=as.POSIXct(y_here$date))
# 2.2 Prepare exogenious variable, that will be used in ARMAX part of ARMAX-GARCH model
ext_regressor_here=df_new[,grepl(paste('RV_',cryptos,sep=''), colnames(df_new))]
# 2.3 Describe ARMAX(1,1)-GARCH(1,1) model
g1=ugarchspec(variance.model = list(model = "sGARCH", external.regressors = as.matrix(ext_regressor_here),
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1), external.regressors = as.matrix(ext_regressor_here),
include.mean = TRUE),
# mean.model  = list(external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "std")
# 2.4 Fit model with appropriate solvers
g1fit=ugarchfit(g1,data=y_here,solver='hybrid')
models_all<-append(models_all,list(g1fit))
# 2.5 Prepare dataset for GARCH regression
df_to_reg=cbind(g1fit@fit$sigma,ext_regressor_here)
colnames(df_to_reg)=c(paste('sigma_',cryptos,sep=''),paste('RV_',cryptos,sep=''))
df_to_reg=as.data.frame(df_to_reg)
# 2.6 Fit regression model GARCH(1,1)~b0+b1*Speculation , where Speculation is the measure of speculation
# as described in 'Blau M. Price dynamics and speculative trading in bitcoinBenjamin,2017'
# and is based on 'Guillermo L. Dynamic Volume-Return Relation of Individual Stocks,2000'
m1<-lm(df_to_reg[,1]~df_to_reg[,2],data = df_to_reg)
print(summary(m1))
# 2.7 Save volatility of a given cryptocyrrency, that is associated (caused by) with speculation
fits_of_garch=append(fits_of_garch,list(m1$fitted.values))
}
}
# 3 . Conduct Granger casuality test to test the H0, which is as follows:
# Volatility, associated  with speculative processes on cryptocurrency X cause ( based on granger test)
# speculative volatility on cryptocurrency Y, where X and Y are currencies from c('BTC','ETH','XRP')
# 3.1. BTC -> ETH
grangertest(log(unlist(fits_of_garch[2])) ~ log(unlist(fits_of_garch[1])), order = 3) #0.194 H0 rejected #0.16
# 3.2. ETH -> BTC
grangertest(log(unlist(fits_of_garch[1])) ~ log(unlist(fits_of_garch[2])), order = 3) #0.001692 ** H0 not rejected  0.001936 **
# 3.3. BTC -> XRP
grangertest(log(unlist(fits_of_garch[3])) ~ log(unlist(fits_of_garch[1])), order = 3) #0.8227 H0 rejected
# 3.4. XRP -> BTC
grangertest(log(unlist(fits_of_garch[1])) ~ log(unlist(fits_of_garch[3])), order = 3) #0.8551 H0 rejected
# 3.3. ETH -> XRP
grangertest(log(unlist(fits_of_garch[3])) ~ log(unlist(fits_of_garch[2])), order = 3) #0.03617 * H0 not rejected
# 3.4. XRP -> ETH
grangertest(log(unlist(fits_of_garch[2])) ~ log(unlist(fits_of_garch[3])), order = 3) # 0.6793 H0 rejected
# 3 . Conduct Granger casuality test to test the H0, which is as follows:
# Volatility, associated  with speculative processes on cryptocurrency X cause ( based on granger test)
# speculative volatility on cryptocurrency Y, where X and Y are currencies from c('BTC','ETH','XRP')
# 3.1. BTC -> ETH
grangertest(log(unlist(fits_of_garch[2])) ~ log(unlist(fits_of_garch[1])), order = 3) #0.194 H0 rejected #0.16
# 3.2. ETH -> BTC
grangertest(log(unlist(fits_of_garch[1])) ~ log(unlist(fits_of_garch[2])), order = 3) #0.001692 ** H0 not rejected  0.001936 **
# 3.3. BTC -> XRP
grangertest(log(unlist(fits_of_garch[3])) ~ log(unlist(fits_of_garch[1])), order = 3) #0.8227 H0 rejected
# 3.4. XRP -> BTC
grangertest(log(unlist(fits_of_garch[1])) ~ log(unlist(fits_of_garch[3])), order = 3) #0.8551 H0 rejected
# 3.3. ETH -> XRP
grangertest(log(unlist(fits_of_garch[3])) ~ log(unlist(fits_of_garch[2])), order = 3) #0.03617 * H0 not rejected
# 3.4. XRP -> ETH
grangertest(log(unlist(fits_of_garch[2])) ~ log(unlist(fits_of_garch[3])), order = 3) # 0.6793 H0 rejected
# 3.4. XRP -> BTC
grangertest(log(unlist(fits_of_garch[1])) ~ log(unlist(fits_of_garch[3])), order = 3) #0.8551 H0 rejected
# 3.3. BTC -> XRP
grangertest(log(unlist(fits_of_garch[3])) ~ log(unlist(fits_of_garch[1])), order = 3) #0.8227 H0 rejected
# 3.4. XRP -> BTC
grangertest(log(unlist(fits_of_garch[1])) ~ log(unlist(fits_of_garch[3])), order = 3) #0.8551 H0 rejected
print(summary(m1))
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(lmtest)
library(rugarch)
source('funcs.R')
# 1. Prepare overall data
df=read.csv('datasets_created_python/merged_all.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
crypto_abr=c('BTC','ETH','XRP')
fits_of_garch=list()
cor(df[,-1])
models_all=list()
# 2. Loop over all currencies and calculate volatility, that was associated with speculative processes
tsdisplay(y_here)
for (cryptos in crypto_abr){
print(cryptos)
steping=dim(df)[1]-1
for (i in seq(1,dim(df)[1]-steping,steping)){
dates=df_new[,grepl('date', colnames(df_new))]
df_new=df[seq(i,i+steping,1),]
# 2.1 Prepare dep.variable y, that will be used in ARMAX-GARCH model
y_here=df_new[,grepl(paste('R_',cryptos,sep=''), colnames(df_new)) | grepl('date', colnames(df_new)) ]
y_here <- xts(y_here[,-1], order.by=as.POSIXct(y_here$date))
# 2.2 Prepare exogenious variable, that will be used in ARMAX part of ARMAX-GARCH model
ext_regressor_here=df_new[,grepl(paste('RV_',cryptos,sep=''), colnames(df_new))]
# 2.3 Describe ARMAX(1,1)-GARCH(1,1) model
g1=ugarchspec(variance.model = list(model = "sGARCH", external.regressors = as.matrix(ext_regressor_here),
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1), external.regressors = as.matrix(ext_regressor_here),
include.mean = TRUE),
# mean.model  = list(external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "std")
# 2.4 Fit model with appropriate solvers
g1fit=ugarchfit(g1,data=y_here,solver='hybrid')
models_all<-append(models_all,list(g1fit))
# 2.5 Prepare dataset for GARCH regression
df_to_reg=cbind(g1fit@fit$sigma,ext_regressor_here)
colnames(df_to_reg)=c(paste('sigma_',cryptos,sep=''),paste('RV_',cryptos,sep=''))
df_to_reg=as.data.frame(df_to_reg)
# 2.6 Fit regression model GARCH(1,1)~b0+b1*Speculation , where Speculation is the measure of speculation
# as described in 'Blau M. Price dynamics and speculative trading in bitcoinBenjamin,2017'
# and is based on 'Guillermo L. Dynamic Volume-Return Relation of Individual Stocks,2000'
m1<-lm(df_to_reg[,1]~df_to_reg[,2],data = df_to_reg)
print(summary(m1))
# 2.7 Save volatility of a given cryptocyrrency, that is associated (caused by) with speculation
fits_of_garch=append(fits_of_garch,list(m1$fitted.values))
}
}
# 3 . Conduct Granger casuality test to test the H0, which is as follows:
# Volatility, associated  with speculative processes on cryptocurrency X cause ( based on granger test)
# speculative volatility on cryptocurrency Y, where X and Y are currencies from c('BTC','ETH','XRP')
# 3.1. BTC -> ETH
grangertest(log(unlist(fits_of_garch[2])) ~ log(unlist(fits_of_garch[1])), order = 3) #0.194 H0 rejected #0.16
# 3.2. ETH -> BTC
grangertest(log(unlist(fits_of_garch[1])) ~ log(unlist(fits_of_garch[2])), order = 3) #0.001692 ** H0 not rejected  0.001936 **
# 3.3. BTC -> XRP
grangertest(log(unlist(fits_of_garch[3])) ~ log(unlist(fits_of_garch[1])), order = 3) #0.8227 H0 rejected
# 3.4. XRP -> BTC
grangertest(log(unlist(fits_of_garch[1])) ~ log(unlist(fits_of_garch[3])), order = 3) #0.8551 H0 rejected
# 3.3. ETH -> XRP
grangertest(log(unlist(fits_of_garch[3])) ~ log(unlist(fits_of_garch[2])), order = 3) #0.03617 * H0 not rejected
# 3.4. XRP -> ETH
grangertest(log(unlist(fits_of_garch[2])) ~ log(unlist(fits_of_garch[3])), order = 3) # 0.6793 H0 rejected
g1fit
