# steping=dim(df)[1]-1
int_values=c()
int_std=c()
for (i in seq(1,dim(df)[1]-steping,steping)){
df_new=df[seq(i,i+steping,1),]
qxts <- xts(df_new[,-1], order.by=as.POSIXct(df_new$date))
# print(arima(df_new$R_Bitcoin,order=c(1,0,0),xreg=df_new$RV_Bitcoin,include.mean = TRUE))
g1=ugarchspec(variance.model = list(model = "sGARCH",
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1),
external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "norm")
g1fit=ugarchfit(g1,data=qxts$R_Bitcoin,solver='hybrid')
int_values<-c(int_values,coef(g1fit)[3])
int_std<-c(int_std,      g1fit@fit$se.coef[3])
df_garch_lm=df_new[,-1]
df_garch_lm$garch11=g1fit@fit$sigma
df_garch_lm$RV_Bitcoin=df_new$RV_Bitcoin
df_garch_lm$V_Bitcoin=df_new$V_Bitcoin
df_garch_lm$R_Bitcoin=df_new$R_Bitcoin
# df_new$RV_Ripple
m1<-lm(garch11~RV_Bitcoin+V_Bitcoin+R_Bitcoin,data = df_garch_lm)
print(summary(m1))
m1$coefficients[2]
}
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('btc_quandl.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
steping=200
# steping=dim(df)[1]-1
int_values=c()
int_std=c()
for (i in seq(1,dim(df)[1]-steping,steping)){
df_new=df[seq(i,i+steping,1),]
qxts <- xts(df_new[,-1], order.by=as.POSIXct(df_new$date))
# print(arima(df_new$R_Bitcoin,order=c(1,0,0),xreg=df_new$RV_Bitcoin,include.mean = TRUE))
g1=ugarchspec(variance.model = list(model = "sGARCH",
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1),
external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "norm")
g1fit=ugarchfit(g1,data=qxts$R_Bitcoin,solver='hybrid')
int_values<-c(int_values,coef(g1fit)[3])
int_std<-c(int_std,      g1fit@fit$se.coef[3])
df_garch_lm=df_new[,-1]
df_garch_lm$garch11=g1fit@fit$sigma
df_garch_lm$RV_Bitcoin=df_new$RV_Bitcoin
df_garch_lm$V_Bitcoin=df_new$V_Bitcoin
df_garch_lm$R_Bitcoin=df_new$R_Bitcoin
# df_new$RV_Ripple
m1<-lm(garch11~RV_Bitcoin+V_Bitcoin+R_Bitcoin,data = df_garch_lm)
print(m1$coefficients[2])
}
df
summary(df)
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('btc_quandl.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
steping=200
# steping=dim(df)[1]-1
int_values=c()
int_std=c()
for (i in seq(1,dim(df)[1]-steping,steping)){
df_new=df[seq(i,i+steping,1),]
qxts <- xts(df_new[,-1], order.by=as.POSIXct(df_new$date))
# print(arima(df_new$R_Bitcoin,order=c(1,0,0),xreg=df_new$RV_Bitcoin,include.mean = TRUE))
g1=ugarchspec(variance.model = list(model = "sGARCH",
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1),
external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "norm")
g1fit=ugarchfit(g1,data=qxts$R_Bitcoin,solver='hybrid')
int_values<-c(int_values,coef(g1fit)[3])
int_std<-c(int_std,      g1fit@fit$se.coef[3])
df_garch_lm=df_new[,-1]
df_garch_lm$garch11=g1fit@fit$sigma
df_garch_lm$RV_Bitcoin=df_new$RV_Bitcoin
df_garch_lm$V_Bitcoin=df_new$V_Bitcoin
df_garch_lm$R_Bitcoin=df_new$R_Bitcoin
# df_new$RV_Ripple
m1<-lm(garch11~RV_Bitcoin+V_Bitcoin+R_Bitcoin,data = df_garch_lm)
print(m1$coefficients[2])
}
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('btc_quandl.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
steping=1000
# steping=dim(df)[1]-1
int_values=c()
int_std=c()
for (i in seq(1,dim(df)[1]-steping,steping)){
df_new=df[seq(i,i+steping,1),]
qxts <- xts(df_new[,-1], order.by=as.POSIXct(df_new$date))
# print(arima(df_new$R_Bitcoin,order=c(1,0,0),xreg=df_new$RV_Bitcoin,include.mean = TRUE))
g1=ugarchspec(variance.model = list(model = "sGARCH",
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1),
external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "norm")
g1fit=ugarchfit(g1,data=qxts$R_Bitcoin,solver='hybrid')
int_values<-c(int_values,coef(g1fit)[3])
int_std<-c(int_std,      g1fit@fit$se.coef[3])
df_garch_lm=df_new[,-1]
df_garch_lm$garch11=g1fit@fit$sigma
df_garch_lm$RV_Bitcoin=df_new$RV_Bitcoin
df_garch_lm$V_Bitcoin=df_new$V_Bitcoin
df_garch_lm$R_Bitcoin=df_new$R_Bitcoin
# df_new$RV_Ripple
m1<-lm(garch11~RV_Bitcoin+V_Bitcoin+R_Bitcoin,data = df_garch_lm)
print(m1$coefficients[2])
}
m1
summary(m1)
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('btc_quandl.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
# steping=1000
steping=dim(df)[1]-1
int_values=c()
int_std=c()
for (i in seq(1,dim(df)[1]-steping,steping)){
df_new=df[seq(i,i+steping,1),]
qxts <- xts(df_new[,-1], order.by=as.POSIXct(df_new$date))
# print(arima(df_new$R_Bitcoin,order=c(1,0,0),xreg=df_new$RV_Bitcoin,include.mean = TRUE))
g1=ugarchspec(variance.model = list(model = "sGARCH",
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1),
external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "norm")
g1fit=ugarchfit(g1,data=qxts$R_Bitcoin,solver='hybrid')
int_values<-c(int_values,coef(g1fit)[3])
int_std<-c(int_std,      g1fit@fit$se.coef[3])
df_garch_lm=df_new[,-1]
df_garch_lm$garch11=g1fit@fit$sigma
df_garch_lm$RV_Bitcoin=df_new$RV_Bitcoin
df_garch_lm$V_Bitcoin=df_new$V_Bitcoin
df_garch_lm$R_Bitcoin=df_new$R_Bitcoin
# df_new$RV_Ripple
m1<-lm(garch11~RV_Bitcoin+V_Bitcoin+R_Bitcoin,data = df_garch_lm)
summary(m1)
print(m1$coefficients[2])
}
summary(m1)
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('df_to_regress.csv')
df
dim(df)
df
df$date=as.POSIXct(as.Date(df$date))
seq(51,dim(df)[1],1)
df=df[seq(51,dim(df)[1],1),]
summary(df)
# steping=1000
steping=dim(df)[1]-1
int_values=c()
int_std=c()
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('df_to_regress.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
# steping=1000
steping=dim(df)[1]-1
int_values=c()
int_std=c()
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('df_to_regress.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
# steping=1000
steping=dim(df)[1]-1
int_values=c()
int_std=c()
for (i in seq(1,dim(df)[1]-steping,steping)){
df_new=df[seq(i,i+steping,1),]
qxts <- xts(df_new[,-1], order.by=as.POSIXct(df_new$date))
# print(arima(df_new$R_Bitcoin,order=c(1,0,0),xreg=df_new$RV_Bitcoin,include.mean = TRUE))
g1=ugarchspec(variance.model = list(model = "sGARCH",
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1),
external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "norm")
g1fit=ugarchfit(g1,data=qxts$R_Bitcoin,solver='hybrid')
int_values<-c(int_values,coef(g1fit)[3])
int_std<-c(int_std,      g1fit@fit$se.coef[3])
df_garch_lm=df_new[,-1]
df_garch_lm$garch11=g1fit@fit$sigma
df_garch_lm$RV_Bitcoin=df_new$RV_Bitcoin
df_garch_lm$V_Bitcoin=df_new$V_Bitcoin
df_garch_lm$R_Bitcoin=df_new$R_Bitcoin
df_garch_lm$log_btc_tot=df_new$log_btc_tot
df_garch_lm$turnover_pct_change=df_new$turnover_pct_change
# df_new$RV_Ripple
m1<-lm(garch11~RV_Bitcoin+R_Bitcoin+turnover_pct_change+log_btc_tot,data = df_garch_lm)
summary(m1)
print(m1$coefficients[2])
}
summary(m1)
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('df_to_regress.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
steping=500
steping=dim(df)[1]-1
int_values=c()
int_std=c()
for (i in seq(1,dim(df)[1]-steping,steping)){
df_new=df[seq(i,i+steping,1),]
qxts <- xts(df_new[,-1], order.by=as.POSIXct(df_new$date))
# print(arima(df_new$R_Bitcoin,order=c(1,0,0),xreg=df_new$RV_Bitcoin,include.mean = TRUE))
g1=ugarchspec(variance.model = list(model = "sGARCH",
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1),
external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "norm")
g1fit=ugarchfit(g1,data=qxts$R_Bitcoin,solver='hybrid')
int_values<-c(int_values,coef(g1fit)[3])
int_std<-c(int_std,      g1fit@fit$se.coef[3])
df_garch_lm=df_new[,-1]
df_garch_lm$garch11=g1fit@fit$sigma
df_garch_lm$RV_Bitcoin=df_new$RV_Bitcoin
df_garch_lm$V_Bitcoin=df_new$V_Bitcoin
df_garch_lm$R_Bitcoin=df_new$R_Bitcoin
df_garch_lm$log_btc_tot=df_new$log_btc_tot
df_garch_lm$turnover_pct_change=df_new$turnover_pct_change
# df_new$RV_Ripple
m1<-lm(garch11~RV_Bitcoin+R_Bitcoin+turnover_pct_change+log_btc_tot,data = df_garch_lm)
summary(m1)
print(summary(m1))
}
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('df_to_regress.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
steping=500
# steping=dim(df)[1]-1
int_values=c()
int_std=c()
for (i in seq(1,dim(df)[1]-steping,steping)){
df_new=df[seq(i,i+steping,1),]
qxts <- xts(df_new[,-1], order.by=as.POSIXct(df_new$date))
# print(arima(df_new$R_Bitcoin,order=c(1,0,0),xreg=df_new$RV_Bitcoin,include.mean = TRUE))
g1=ugarchspec(variance.model = list(model = "sGARCH",
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1),
external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "norm")
g1fit=ugarchfit(g1,data=qxts$R_Bitcoin,solver='hybrid')
int_values<-c(int_values,coef(g1fit)[3])
int_std<-c(int_std,      g1fit@fit$se.coef[3])
df_garch_lm=df_new[,-1]
df_garch_lm$garch11=g1fit@fit$sigma
df_garch_lm$RV_Bitcoin=df_new$RV_Bitcoin
df_garch_lm$V_Bitcoin=df_new$V_Bitcoin
df_garch_lm$R_Bitcoin=df_new$R_Bitcoin
df_garch_lm$log_btc_tot=df_new$log_btc_tot
df_garch_lm$turnover_pct_change=df_new$turnover_pct_change
# df_new$RV_Ripple
m1<-lm(garch11~RV_Bitcoin+R_Bitcoin+turnover_pct_change+log_btc_tot,data = df_garch_lm)
summary(m1)
print(summary(m1))
}
df_garch_lm
cor(df_garch_lm)
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('df_to_regress.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
steping=500
# steping=dim(df)[1]-1
int_values=c()
int_std=c()
for (i in seq(1,dim(df)[1]-steping,steping)){
df_new=df[seq(i,i+steping,1),]
qxts <- xts(df_new[,-1], order.by=as.POSIXct(df_new$date))
# print(arima(df_new$R_Bitcoin,order=c(1,0,0),xreg=df_new$RV_Bitcoin,include.mean = TRUE))
g1=ugarchspec(variance.model = list(model = "sGARCH",
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1),
external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "norm")
g1fit=ugarchfit(g1,data=qxts$R_Bitcoin,solver='hybrid')
int_values<-c(int_values,coef(g1fit)[3])
int_std<-c(int_std,      g1fit@fit$se.coef[3])
df_garch_lm=df_new[,-1]
df_garch_lm$garch11=g1fit@fit$sigma
df_garch_lm$RV_Bitcoin=df_new$RV_Bitcoin
df_garch_lm$V_Bitcoin=df_new$V_Bitcoin
df_garch_lm$R_Bitcoin=df_new$R_Bitcoin
df_garch_lm$log_btc_tot=df_new$log_btc_tot
df_garch_lm$turnover_pct_change=df_new$turnover_pct_change
cor(df_garch_lm)
# df_new$RV_Ripple
m1<-lm(garch11~RV_Bitcoin+R_Bitcoin+turnover_pct_change+log_btc_tot,data = df_garch_lm)
summary(m1)
print(summary(m1))
}
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('df_to_regress.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
steping=500
# steping=dim(df)[1]-1
int_values=c()
int_std=c()
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('df_to_regress.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
# steping=500
steping=dim(df)[1]-1
int_values=c()
int_std=c()
for (i in seq(1,dim(df)[1]-steping,steping)){
df_new=df[seq(i,i+steping,1),]
qxts <- xts(df_new[,-1], order.by=as.POSIXct(df_new$date))
# print(arima(df_new$R_Bitcoin,order=c(1,0,0),xreg=df_new$RV_Bitcoin,include.mean = TRUE))
g1=ugarchspec(variance.model = list(model = "sGARCH",
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1),
external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "norm")
g1fit=ugarchfit(g1,data=qxts$R_Bitcoin,solver='hybrid')
int_values<-c(int_values,coef(g1fit)[3])
int_std<-c(int_std,      g1fit@fit$se.coef[3])
df_garch_lm=df_new[,-1]
df_garch_lm$garch11=g1fit@fit$sigma
df_garch_lm$RV_Bitcoin=df_new$RV_Bitcoin
df_garch_lm$V_Bitcoin=df_new$V_Bitcoin
df_garch_lm$R_Bitcoin=df_new$R_Bitcoin
df_garch_lm$log_btc_tot=df_new$log_btc_tot
df_garch_lm$turnover_pct_change=df_new$turnover_pct_change
# cor(df_garch_lm)
# df_new$RV_Ripple
m1<-lm(garch11~RV_Bitcoin+R_Bitcoin+turnover_pct_change+log_btc_tot,data = df_garch_lm)
summary(m1)
print(summary(m1))
}
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('df_to_regress.csv')
View(df)
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('df_to_regress.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
# steping=500
steping=dim(df)[1]-1
int_values=c()
int_std=c()
for (i in seq(1,dim(df)[1]-steping,steping)){
df_new=df[seq(i,i+steping,1),]
qxts <- xts(df_new[,-1], order.by=as.POSIXct(df_new$date))
# print(arima(df_new$R_Bitcoin,order=c(1,0,0),xreg=df_new$RV_Bitcoin,include.mean = TRUE))
g1=ugarchspec(variance.model = list(model = "sGARCH",
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1),
external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "norm")
g1fit=ugarchfit(g1,data=qxts$R_Bitcoin,solver='hybrid')
int_values<-c(int_values,coef(g1fit)[3])
int_std<-c(int_std,      g1fit@fit$se.coef[3])
df_garch_lm=df_new[,-1]
df_garch_lm$garch11=g1fit@fit$sigma
df_garch_lm$RV_Bitcoin=df_new$RV_Bitcoin
df_garch_lm$V_Bitcoin=df_new$V_Bitcoin
df_garch_lm$R5_Bitcoin=df_new$R5_Bitcoin
df_garch_lm$log_btc_tot=df_new$log_btc_tot
df_garch_lm$turnover_pct_change=df_new$turnover_pct_change
# cor(df_garch_lm)
# df_new$RV_Ripple
m1<-lm(garch11~RV_Bitcoin+R_Bitcoin+turnover_pct_change+log_btc_tot,data = df_garch_lm)
summary(m1)
print(summary(m1))
}
library(forecast)
library(quantmod)
library(timeSeries)
library(tseries)
library(xts)
library(rugarch)
source('funcs.R')
df=read.csv('df_to_regress.csv')
df$date=as.POSIXct(as.Date(df$date))
df=df[seq(51,dim(df)[1],1),]
summary(df)
# steping=500
steping=dim(df)[1]-1
int_values=c()
int_std=c()
for (i in seq(1,dim(df)[1]-steping,steping)){
df_new=df[seq(i,i+steping,1),]
qxts <- xts(df_new[,-1], order.by=as.POSIXct(df_new$date))
# print(arima(df_new$R_Bitcoin,order=c(1,0,0),xreg=df_new$RV_Bitcoin,include.mean = TRUE))
g1=ugarchspec(variance.model = list(model = "sGARCH",
garchOrder = c(1,1)),
mean.model  = list(armaOrder = c(1,1),
external.regressors = as.matrix(df_new[,c(2)])),
distribution.model = "norm")
g1fit=ugarchfit(g1,data=qxts$R_Bitcoin,solver='hybrid')
int_values<-c(int_values,coef(g1fit)[3])
int_std<-c(int_std,      g1fit@fit$se.coef[3])
df_garch_lm=df_new[,-1]
df_garch_lm$garch11=g1fit@fit$sigma
df_garch_lm$RV_Bitcoin=df_new$RV_Bitcoin
df_garch_lm$V_Bitcoin=df_new$V_Bitcoin
df_garch_lm$R5_Bitcoin=df_new$R5_Bitcoin
df_garch_lm$log_btc_tot=df_new$log_btc_tot
df_garch_lm$turnover_pct_change=df_new$turnover_pct_change
# cor(df_garch_lm)
# df_new$RV_Ripple
m1<-lm(garch11~RV_Bitcoin+R5_Bitcoin+turnover_pct_change+log_btc_tot,data = df_garch_lm)
summary(m1)
print(summary(m1))
}
